Define A = C/S, B = K/S, R = rT and let y = Ïƒ SQRT(T) = IV SQRT(T).
The Black-Scholes formula then looks like: 
[1]       A = N(d1) - B e-R N(d2) 
where 
      d1 = [ -log(B) + R + (1/2)y2 ] / y 
and 
      d2 = d1 - y
Our problem is to find y in terms of A, B and R.
We rewrite [1] like so: 
[2]       Error = N(d1) - B e-R N(d2) - A
If, for a given set of numbers A, B and R, a y-value makes Error = 0, then IV = y / SQRT(T).


               N(d1) - B e-R N(d2) - A=0
				 
              equation:   N(( -log(B) + R + (1/2)y2 ) / y ) - B e-R N((( -log(B) + R + (1/2)y2 ) / y ) -y) - A=0
			  
			  function: f(y)=N(( -log(B) + R + (1/2)y2 ) / y ) - B e-R N((( -log(B) + R + (1/2)y2 ) / y ) -y) - A
				 
			  find y1  and y2 such that f(y1) and f(y2) has opposite signs to function values
			  assume f(y1)=+ve   and f(y2)=-ve
		      Yc= 0.5( y1+y2)
               now  if f(Yc)=-ve then new range  y1(+) and Yc(-) 
			   Yd=0.5 (y1+yc)
			   ..
			   ..

  stop when  f(Y) reaches close  to Zero


References:

Bisection algorithm:http://users.csc.tntech.edu/~mjkosa/2400s11/Bisection/Bisection.java

Calculating implied volatility:http://www.gummy-stuff.org/implied-volatility.htm



  /*********************** Modified Java **********************************/
   
   
//Case2: if we have dividend rate 
//Log (S/K) + [( R -dR + 0.5(V^2) )T]		
D1=(Math.log(S/K)+ ( R -dR + 0.5*V*V)*T)/(V*Math.sqrt(T));
D2=D1-V*Math.sqrt(T);
		
//Call Price= S *  NORMSDIST (D1) * e^(-dRT) - [ K e^(-RT)  * NORMSDIST (D2)]
  C=S*Distribution.NORMSDIST(D1)*Math.exp(-dR*T)-(K*Math.exp(-R*T)*Distribution.NORMSDIST(D2));
		
//Put Price=EXP(-R*T)*K*NORMSDIST(-D2)-EXP(-dR*T)*S*NORMSDIST(-D1))
  P=K*Math.exp(-R*T)*Distribution.NORMSDIST(-D2)-(S*Distribution.NORMSDIST(-D1)*Math.exp(-dR*T));

			
/*Delta*/
			
//Call :=  e^(-dRT)*NORMSDIST (D1)
  DeltaC=Math.exp(-dR*T)*Distribution.NORMSDIST(D1);
//Put :=e^(-dRT)*(NORMSDIST(D1)-1)
  DeltaP=Math.exp(-dR*T)*(Distribution.NORMSDIST(D1)-1);
			
/*Gammma*/
  //=e^(-dRT) * e^(-0.5D1^2)/( S*V*sqrt(T) *SQRT(2Pi) )
  Gamma=Math.exp(-dR*T) * Math.exp(-0.5*D1*D1) /( S*V*Math.sqrt(T)*Math.sqrt(2*Math.PI));
			
//Theta
  //Call Theta=(1/T) *( -( (S*V*e^(-dR*T)*e^(-05*D1*D1))/(2*SQRT(T)*SQRT(2Pi)) ) -R*K*e(-RT)N(D2)+dR*S*e^(-dR*T)*N(D1) )
  ThetaC= (1/T)* (-( (S*V*Math.exp(-dR*T)*Math.exp(-0.5*D1*D1))/(2*Math.sqrt(T)*Math.sqrt(2*Math.PI)) ) -R*K*Math.exp(-R*T)*Distribution.NORMSDIST(D2)+dR*S*Math.exp(-dR*T)*Distribution.NORMSDIST(D1));
   
  //Put Theta=(1/T) *( -( (S*V*e^(-dR*T)*e^(-05*D1*D1))/(2*SQRT(T)*SQRT(2Pi)) ) +R*K*e(-RT)N(-D2)+dR*S*e^(-dR*T)*N(-D1) )
  ThetaP= (1/T)* (-( (S*V*Math.exp(-dR*T)*Math.exp(-0.5*D1*D1))/(2*Math.sqrt(T)*Math.sqrt(2*Math.PI)) )+R*K*Math.exp(-R*T)*Distribution.NORMSDIST(-D2)+dR*S*Math.exp(-dR*T)*Distribution.NORMSDIST(-D1));           
   
//Vega
  //=(S*e^(-dR*T)*SQRT(T)*e^(-0.5*D1*D1) )/(100*SQRT(2*Pi))
 Vaga= (S*Math.exp(-dR*T)*Math.sqrt(T)*Math.exp(-0.5*D1*D1)) /(100*Math.sqrt(2*Math.PI));
 

//Rho
  //Call Rho=  (K*T*e^(-RT)*N(D2)) /(100)
    RhoC=(K*T*Math.exp(-R*T)*Distribution.NORMSDIST(D2))/(100)
  
  //Put  Rho=(K*T*e^(-RT)*N(-D2)) /(-100)
	RhoP=(K*T*Math.exp(-R*T)*Distribution.NORMSDIST(-D2))/(100)
  

/************************** Modified Java equations **************************************/



 //Case2: if we have dividend rate 
//Log (S/K) + [( R -dR + 0.5(V^2) )T]		
D1=((Math.log(S/K)+ ( R -dR + 0.5*V*V)*T)/(V*Math.sqrt(T)));
D2=(((Math.log(S/K)+ ( R -dR + 0.5*V*V)*T)/(V*Math.sqrt(T)))-V*Math.sqrt(T));

//Call Price= S *  NORMSDIST (D1) * e^(-dRT) - [ K e^(-RT)  * NORMSDIST (D2)]
  C=S*Distribution.NORMSDIST(((Math.log(S/K)+ ( R -dR + 0.5*V*V)*T)/(V*Math.sqrt(T))))*Math.exp(-dR*T)-(K*Math.exp(-R*T)*Distribution.NORMSDIST((((Math.log(S/K)+ ( R -dR + 0.5*V*V)*T)/(V*Math.sqrt(T)))-V*Math.sqrt(T))));

//Put Price=EXP(-R*T)*K*NORMSDIST(-D2)-EXP(-dR*T)*S*NORMSDIST(-D1))
  P=K*Math.exp(-R*T)*Distribution.NORMSDIST(-(((Math.log(S/K)+ ( R -dR + 0.5*V*V)*T)/(V*Math.sqrt(T)))-V*Math.sqrt(T)))-(S*Distribution.NORMSDIST(-((Math.log(S/K)+ ( R -dR + 0.5*V*V)*T)/(V*Math.sqrt(T))))*Math.exp(-dR*T));


/*Delta*/

//Call :=  e^(-dRT)*NORMSDIST (D1)
  DeltaC=Math.exp(-dR*T)*Distribution.NORMSDIST(((Math.log(S/K)+ ( R -dR + 0.5*V*V)*T)/(V*Math.sqrt(T))));
//Put :=e^(-dRT)*(NORMSDIST(D1)-1)
  DeltaP=Math.exp(-dR*T)*(Distribution.NORMSDIST(((Math.log(S/K)+ ( R -dR + 0.5*V*V)*T)/(V*Math.sqrt(T))))-1);

/*Gammma*/
  //=e^(-dRT) * e^(-0.5D1^2)/( S*V*sqrt(T) *SQRT(2Pi) )
  Gamma=Math.exp(-dR*T) * Math.exp(-0.5* Math.pow(((Math.log(S/K)+ ( R -dR + 0.5*V*V)*T)/(V*Math.sqrt(T))),2)) /( S*V*Math.sqrt(T)*Math.sqrt(2*Math.PI));

//Theta
  //Call Theta=(1/T) *( -( (S*V*e^(-dR*T)*e^(-05*D1*D1))/(2*SQRT(T)*SQRT(2Pi)) ) -R*K*e(-RT)N(D2)+dR*S*e^(-dR*T)*N(D1) )
  ThetaC= (1/T)* (-( (S*V*Math.exp(-dR*T)*Math.exp(-0.5* Math.pow(((Math.log(S/K)+ ( R -dR + 0.5*V*V)*T)/(V*Math.sqrt(T))),2)))/(2*Math.sqrt(T)*Math.sqrt(2*Math.PI)) ) -R*K*Math.exp(-R*T)*Distribution.NORMSDIST((((Math.log(S/K)+ ( R -dR + 0.5*V*V)*T)/(V*Math.sqrt(T)))-V*Math.sqrt(T)))+dR*S*Math.exp(-dR*T)*Distribution.NORMSDIST(((Math.log(S/K)+ ( R -dR + 0.5*V*V)*T)/(V*Math.sqrt(T)))));
   
  //Put Theta=(1/T) *( -( (S*V*e^(-dR*T)*e^(-05*D1*D1))/(2*SQRT(T)*SQRT(2Pi)) ) +R*K*e(-RT)N(-D2)+dR*S*e^(-dR*T)*N(-D1) )
  ThetaP= (1/T)* (-( (S*V*Math.exp(-dR*T)*Math.exp(-0.5* Math.pow(((Math.log(S/K)+ ( R -dR + 0.5*V*V)*T)/(V*Math.sqrt(T))),2)))/(2*Math.sqrt(T)*Math.sqrt(2*Math.PI)) )+R*K*Math.exp(-R*T)*Distribution.NORMSDIST(-(((Math.log(S/K)+ ( R -dR + 0.5*V*V)*T)/(V*Math.sqrt(T)))-V*Math.sqrt(T)))+dR*S*Math.exp(-dR*T)*Distribution.NORMSDIST(-((Math.log(S/K)+ ( R -dR + 0.5*V*V)*T)/(V*Math.sqrt(T)))));           
   
//Vega
  //=(S*e^(-dR*T)*SQRT(T)*e^(-0.5*D1*D1) )/(100*SQRT(2*Pi))
 Vaga= (S*Math.exp(-dR*T)*Math.sqrt(T)*Math.exp(-0.5* Math.pow(((Math.log(S/K)+ ( R -dR + 0.5*V*V)*T)/(V*Math.sqrt(T))),2))) /(100*Math.sqrt(2*Math.PI));
 

//Rho
  //Call Rho=  (K*T*e^(-RT)*N(D2)) /(100)
    RhoC=(K*T*Math.exp(-R*T)*Distribution.NORMSDIST((((Math.log(S/K)+ ( R -dR + 0.5*V*V)*T)/(V*Math.sqrt(T)))-V*Math.sqrt(T))))/(100)
  
  //Put  Rho=(K*T*e^(-RT)*N(-D2)) /(-100)
	RhoP=(K*T*Math.exp(-R*T)*Distribution.NORMSDIST(-(((Math.log(S/K)+ ( R -dR + 0.5*V*V)*T)/(V*Math.sqrt(T)))-V*Math.sqrt(T))))/(100)
